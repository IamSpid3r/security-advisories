
# Vulnerability in Android library while parsing Ogg audio files


## 1. Advisory Information

**Title:** Vulnerability in Android library while parsing Ogg audio files

**Advisory ID:** CVE-2015-3869

**Advisory URL:** [http://www.fundacionsadosky.org.ar/publicaciones-2](http://www.fundacionsadosky.org.ar/publicaciones-2)

**Date published:** 2015-12-1

**Date of last update:** 2015-12-01

**Vendors contacted:** Google

**Release mode:** Coordinated release



## 2. Vulnerability Information

**Class:** Heap-based Buffer Overflow [[http://cwe.mitre.org/data/definitions/122.html](http://cwe.mitre.org/data/definitions/122.html)]

**Impact:** Code execution

**Remotely Exploitable:** Yes

**Locally Exploitable:** No

**CVE Identifier:** [http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-3869](http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-3869)



## 3. Vulnerability Description

Stagefright is a media library running in Android devices used as a backend engine for playing various multimedia formats such as MP3, MKV, MP4, etc.

A vulnerability exists in the library that is triggered when procesing a malformed Vorbis header included in an Ogg audio file. The bug can be used by a potential attacker to perform arbitrary operations on the victim device. 

In order to exploit the problem an attacker would need a victim to open an specially crafted Vorbin header in an Ogg file. This could be done via sending an MMS message to the device, tricking the user into browsing a site controlled by the attacker or sending it via to app installed in the victim's device such as an instant messaging app.

The problem was assigned as critical severity by the vendor (Google) and it affects around 93% of Android mobile devices around the world.


## 4. Vulnerable packages

* Android Lollipop 5.1.1 without October security updates.

## 5. Vendor Information, Solutions and Workarounds

  Vendor fixed issue in the Android Open Source Project (AOSP) repository on October 2015 and notified it's partners on September 10, 2015. The problem was independently found by Chiachih Wu and Xuxian Jiang of C0re Team. 


## 6. Credits

This vulnerability was discovered and researched by Joaquín Manuel Rinaudo and Iván Arce. The publication of this advisory was coordinated by Programa Seguridad en TIC. 

## 7. Technical Description

In libstagefright the OggExtrator extracts metadata from a Vorbis header using the [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#verifyHeader](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#verifyHeader)  method which parses three types of packets that can be found in the header.

A packet of type 3 contains metadata and its first unpacked from a bitstream and parsed with [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#parseFileMetaData](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#parseFileMetaData) as seen in line 795 below

```
789        case 3:
790        {
791            if (0 != _vorbis_unpack_comment(&mVc, &bits)) {
792                return ERROR_MALFORMED;
793            }
794
795            parseFileMetaData();
796            break;
797        }
798


```

According to the Vorbis spec the metadata is a series of comments in the form: key "=" value where 'key' is one element from a set of known strings and 'value' is a based64 encoded string.

The metadata is parsed by [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#parseVorbisComment](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#parseVorbisComment) shown below

```
void parseVorbisComment(
834        const sp<MetaData> &fileMeta, const char *comment, size_t commentLength)
835{
836    struct {
837        const char *const mTag;
838        uint32_t mKey;
839    } kMap[] = {
840        { "TITLE", kKeyTitle },
841        { "ARTIST", kKeyArtist },
842        { "ALBUMARTIST", kKeyAlbumArtist },
843        { "ALBUM ARTIST", kKeyAlbumArtist },
844        { "COMPILATION", kKeyCompilation },
845        { "ALBUM", kKeyAlbum },
846        { "COMPOSER", kKeyComposer },
847        { "GENRE", kKeyGenre },
848        { "AUTHOR", kKeyAuthor },
849        { "TRACKNUMBER", kKeyCDTrackNumber },
850        { "DISCNUMBER", kKeyDiscNumber },
851        { "DATE", kKeyDate },
852        { "LYRICIST", kKeyWriter },
853        { "METADATA_BLOCK_PICTURE", kKeyAlbumArt },
854        { "ANDROID_LOOP", kKeyAutoLoop },
855    };
856
857        for (size_t j = 0; j < sizeof(kMap) / sizeof(kMap[0]); ++j) {
858            size_t tagLen = strlen(kMap[j].mTag);
859            if (!strncasecmp(kMap[j].mTag, comment, tagLen)
860                    && comment[tagLen] == '=') {
861                if (kMap[j].mKey == kKeyAlbumArt) {
862                    extractAlbumArt(
863                            fileMeta,
864                            &comment[tagLen + 1],
865                            commentLength - tagLen - 1);
866                } else if (kMap[j].mKey == kKeyAutoLoop) {
867                    if (!strcasecmp(&comment[tagLen + 1], "true")) {
868                        fileMeta->setInt32(kKeyAutoLoop, true);
869                    }
870                } else {
871                    fileMeta->setCString(kMap[j].mKey, &comment[tagLen + 1]);
872                }
873            }
874        }
875
876}


```

A comment of type "METADATA_BLOCK_PICTURE" is parsed calling  [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#extractAlbumArt](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#extractAlbumArt) at line 862.

The entire code of extractAlbumArt is provided below since it has several bugs to be analyzed:

```
943 static void extractAlbumArt(
944        const sp<MetaData> &fileMeta, const void *data, size_t size) {
945    ALOGV("extractAlbumArt from '%s'", (const char *)data);
946
947    size_t flacSize;
948    uint8_t *flac = DecodeBase64((const char *)data, size, &flacSize);
949
950    if (flac == NULL) {
951        ALOGE("malformed base64 encoded data.");
952        return;
953    }
954
955    ALOGV("got flac of size %zu", flacSize);
956
957    uint32_t picType;


```

The local variables below are all read directly form the input buffer as unsigned integers. Later on they will be used to perform pointer arithmetic to index into the input buffer. 

The validation of these variables throughout the extractAlbumArt method does not consider values that may make the calculations overflow and wrap around, thus failing to detect error conditions.

```
958    uint32_t typeLen;
959    uint32_t descLen;
960    uint32_t dataLen;


```

This fixed size buffer can be overflown in a memcpy() call at line 983 

```
961    char type[128];
962
963    if (flacSize < 8) {
964        goto exit;
965    }
966
967    picType = U32_AT(flac);
968
969    if (picType != 3) {
970        // This is not a front cover.
971        goto exit;
972    }
973
974    typeLen = U32_AT(&flac[4]);
975    if (typeLen + 1 > sizeof(type)) {
976        goto exit;
977    }
978
979    if (flacSize < 8 + typeLen) {
980        goto exit;
981    }
982
983    memcpy(type, &flac[8], typeLen);
984    type[typeLen] = '\0';


```

A typeLen of 0xffffffff will pass the two if conditions above and lead to memory corruption in the following memcpy() call.  The file POC_typeLen_overflow.ogg is a sample PoC file that will reproduce the bug. 

Fortunately, the overflow is catched on versions of Android compiled with -DFORTIFY_SOURCE (>= 4.2_r1)
but older versions may be exploitable.

At least another bug exist in the remaining code.

```
985
986    ALOGV("picType = %d, type = '%s'", picType, type);
987
988    if (!strcmp(type, "-->")) {
989        // This is not inline cover art, but an external url instead.
990        goto exit;
991    }
992
993    descLen = U32_AT(&flac[8 + typeLen]);
994
995    if (flacSize < 32 + typeLen + descLen) {
996        goto exit;
997    }
998
999    dataLen = U32_AT(&flac[8 + typeLen + 4 + descLen + 16]);
1000
1001    if (flacSize < 32 + typeLen + descLen + dataLen) {
1002        goto exit;
1003    }
1004
1005    ALOGV("got image data, %zu trailing bytes",
1006         flacSize - 32 - typeLen - descLen - dataLen);
1007
1008    fileMeta->setData(
1009            kKeyAlbumArt, 0, &flac[8 + typeLen + 4 + descLen + 20], dataLen);
1010
1011    fileMeta->setCString(kKeyAlbumArtMIME, type);
1012
1013 exit:
1014    free(flac);
1015    flac = NULL;
1016 }
1017


```

Like the the case of 'typeLen', we see that  'descLen' and 'dataLen' are read directly from the input buffer
and the various checks to ensure they do not point past the overall size of the input fail to account for large values that would wrap when summed.

A large value of dataLen may trigger a condition for memory corruption in the call to setData at line 1008

To investigate further we must review the setData method found in [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/MetaData.cpp#269](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/MetaData.cpp#269)
```
269 void MetaData::typed_data::setData(
270        uint32_t type, const void *data, size_t size) {
271    clear();
272
273    mType = type;
274    allocateStorage(size);
275    memcpy(storage(), data, size);
276 }
277


```

setData calls allocateStorage() to allocate an internal buffer and the copies the input data to it. Unfortunately it does not check the result of the call to allocateStorage() which may lead to memory corruption in the memcpy() call at line 275. The file POC_dataLen_overflow.ogg is a POC of said bug.


## 8. Report Timeline

* **2015-08-12:** 
        Security issue opened in Google's Android issue tracker. Technical details of the vulnerabilities sent to the vendor.
        
* **2015-08-13:** 
        The vendor marked the vulnerability as a duplicate of issue 182053 reported previously on August 4th, 2015 (AndroidID-23036083).
        
* **2015-08-13:** 
        Android issue 182921 has been merged into this issue (possibly an independent report of the same vulnerability).
        
* **2015-08-17:** 
         CVE-2015-3869 assigned to this vulnerability
        
* **2015-08-17:** 
         Issue 184064 has been merged into this issue. Confirmed indepedent report of the same vulnerability.
        
* **2015-10-05:** 
        Nexus security bulletin - October 2015 published.
        
* **2015-10-09:** 
        Vendor released a patch in Android Open Source Project (AOSP) repository.
        
* **2015-12-1:** 
         Advisory was released. 

## 9. References



## 10. About Fundación Dr. Manuel Sadosky

The Dr. Manuel Sadosky Foundation is a mixed (public / private) institution whose goal is to promote stronger and closer interaction between industry and the scientific-technological system in all aspects related to Information and Communications Technology (ICT). The Foundation was formally created by a Presidential Decree in 2009. Its Chairman is the Minister of Science, Technology, and Productive Innovation of Argentina; and the Vice-chairmen are the chairmen of the country’s most important ICT chambers: The Software and Computer Services Chamber (CESSI) and the Argentine Computing and Telecommunications Chamber (CICOMRA). For more information visit: [http://www.fundacionsadosky.org.ar](http://www.fundacionsadosky.org.ar)

## 11. Copyright Notice

The contents of this advisory are copyright (c) 2014 Fundación Sadosky and are licensed under a Creative Commons Attribution Non-Commercial Share-Alike 4.0 License: [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/)