<?xml version="1.0" encoding="UTF-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:xdt="http://www.w3.org/2005/xpath-datatypes" xmlns:err="http://www.w3.org/2005/xqt-errors"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><title>Fundación Dr. Manuel Sadosky - Programa STIC Advisory</title><script language="javascript">
						function showFullCode(textareaId)
						{
								theTextArea = document.getElementById(textareaId);
								content = theTextArea.value.split(String.fromCharCode(10));
								height = (400 + content.length % 500) % 800;
								win = window.open("", "Window3", "width=800,height=" + height + ",scrollbars=yes");
								win.document.writeln("<pre>" + theTextArea.innerHTML + "</pre>");
								win.document.close();
								return false;
						 }
					</script></head><body><div id="content-title">Vulnerabilidad en biblioteca de Android que procesa archivos de audio Ogg</div>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <h3>1.
					Información del reporte</h3>
    <p>
      <strong>Título: </strong>Vulnerabilidad en biblioteca de Android que procesa archivos de audio Ogg<br/><strong>Reporte ID: </strong>CVE-2015-3869<br/><strong>Reporte URL: </strong><a target="_blank" href="http://www.fundacionsadosky.org.ar/publicaciones-2">http://www.fundacionsadosky.org.ar/publicaciones-2</a><br/><strong>Fecha de publicación: </strong>2015-12-01<br/><strong>Fecha de última actualización: </strong>2015-12-1<br/><strong>Fabricantes contactados: </strong>Google<br/><strong>Modo de publicación: </strong>Coordinado<br/>
    </p>        
  
  
  <h3>2.
					Información de vulnerabilidades</h3>
    <p>
      <strong>Clase: </strong>Heap-based Buffer Overflow [<a target="_blank" href="http://cwe.mitre.org/data/definitions/122.html">CWE-122</a>]<br/><strong>Impacto: </strong>Perdida de datos<br/><strong>Remotamente explotable: </strong>Yes<br/><strong>Localmente explotable: </strong>No<br/><strong>Identificador CVE: </strong><a target="_blank" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-3869">CVE-2015-3869</a><br/>
    </p>
  
  
<h3>3.
					Descripción de vulnerabilidad</h3>
<p>
Stagefright es una biblioteca que corre en dispositivos Android y es utilizada como motor multimedia al procesar formatos como MP3, MP4, MKV, etc. 
</p>
<p>
Existe una vulnerabilidad en la biblioteca que se manifiesta al procesar archivos de audio con formato Ogg que incluyan un encabezado de tipo Vorbis malformado. El bug puede ser utilizado por un potencial atacante para ejecutar comandos de manera remota en un dispositivo vulnerable y obtener acceso a los datos alojados en él.
</p>
<p>
Para explotar el problema, un potencial atacante requeriría que la victima abra un archivo Ogg que incluya un encabezado tipo Vorbis diseñado especialmente para el ataque. Esto podría lograrse ya sea enviado el archivo en un mensaje de texto, engañando al la víctima para que lo descarge de un sitio web controlado por el atacante o copiandolo desde alguna aplicación instalada en el dispositivo, por ejemplo alguna de mensajería instantánea.
</p>
<p>
 El problema fue catalogado como de severidad crítica por el fabricante (Google) y afecta aproximadamente al 93% de los dispositivos móviles Android de todo el mundo.
</p>

<h3>4.
					Paquetes vulnerables</h3>
<p>
<ul>
  <li class="smbull3">Dispositivos corriendo Android Lollipop 5.1.1 sin las actualizaciones de seguridad de Octubre.</li>
</ul>
</p>


<h3>5.
					Información y soluciones del fabricante</h3>

<p>
El fabricante solucionó el problema en el repositorio Android Open Source Project (AOSP) en Octubre del 2015 y notificó a sus asociados en Septiembre 10, 2015. El problema fue encontrado independientemente por Chiachih Wu y Xuxian Jiang de C0re Team.
</p>



<h3>6.
					Créditos</h3>
<p>
Las vulnerabilidades fueron descubiertas e investigadas por Joaquín Manuel Rinaudo and Iván Arce. La publicación de este reporte fue coordinada por Programa Seguridad en TIC. 
</p>


<a id="td"></a><h3>7.
					Descripción técnica</h3>
<p>
En libstagefright, OggExtractor está encargado de extraer la metadata de los encabezados de tipo Vorbis utilizando el método <a target="_blank" href="http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#verifyHeader">verifyHeader</a>. Este método procesa tres tipos de paquetes que pueden ser encontrados en el encabezado.
</p>

<p>
Un paquete de tipo 3 contiene metadata y es primero desempacado como un bistream y procesado con <a target="_blank" href="http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#parseFileMetaData">parseFileMedata</a> como se puede ver en la linea 795:
</p>

</p><textarea rows="12" cols="60" wrap="off" style="overflow:auto" id="code1">789        case 3:
790        {
791            if (0 != _vorbis_unpack_comment(&amp;mVc, &amp;bits)) {
792                return ERROR_MALFORMED;
793            }
794
795            parseFileMetaData();
796            break;
797        }
798

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code1');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>

<p>
De acuerdo a las especificaciones de Vorbis, la metadata es una serie de comentarios de la forma clave "=" valor donde clave es un elemento de un conjunto de cadenas de caracteres conocidas y el valor un string codificado en base64.
</p>

<p>
La metadata es procesada por <a target="_blank" href="http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#parseVorbisComment">parseVorbisComment</a> como se muestra abajo:
</p>

</p><textarea rows="28" cols="60" wrap="off" style="overflow:auto" id="code2">void parseVorbisComment(
834        const sp&lt;MetaData&gt; &amp;fileMeta, const char *comment, size_t commentLength)
835{
836    struct {
837        const char *const mTag;
838        uint32_t mKey;
839    } kMap[] = {
840        { "TITLE", kKeyTitle },
841        { "ARTIST", kKeyArtist },
842        { "ALBUMARTIST", kKeyAlbumArtist },
843        { "ALBUM ARTIST", kKeyAlbumArtist },
844        { "COMPILATION", kKeyCompilation },
845        { "ALBUM", kKeyAlbum },
846        { "COMPOSER", kKeyComposer },
847        { "GENRE", kKeyGenre },
848        { "AUTHOR", kKeyAuthor },
849        { "TRACKNUMBER", kKeyCDTrackNumber },
850        { "DISCNUMBER", kKeyDiscNumber },
851        { "DATE", kKeyDate },
852        { "LYRICIST", kKeyWriter },
853        { "METADATA_BLOCK_PICTURE", kKeyAlbumArt },
854        { "ANDROID_LOOP", kKeyAutoLoop },
855    };
856
857        for (size_t j = 0; j &lt; sizeof(kMap) / sizeof(kMap[0]); ++j) {
858            size_t tagLen = strlen(kMap[j].mTag);
859            if (!strncasecmp(kMap[j].mTag, comment, tagLen)
860                    &amp;&amp; comment[tagLen] == '=') {
861                if (kMap[j].mKey == kKeyAlbumArt) {
862                    extractAlbumArt(
863                            fileMeta,
864                            &amp;comment[tagLen + 1],
865                            commentLength - tagLen - 1);
866                } else if (kMap[j].mKey == kKeyAutoLoop) {
867                    if (!strcasecmp(&amp;comment[tagLen + 1], "true")) {
868                        fileMeta-&gt;setInt32(kKeyAutoLoop, true);
869                    }
870                } else {
871                    fileMeta-&gt;setCString(kMap[j].mKey, &amp;comment[tagLen + 1]);
872                }
873            }
874        }
875
876}

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code2');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>

<p>
Un comentario del tipo "METADATA_BLOCK_PICTURE"es procesado llamando a <a target="_blank" href="http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#extractAlbumArt">extractAlbumArt</a>  en la linea 862. 
</p>

<p>
A continuación se copia todo el código de extractAlbumArt dado que tiene varios bugs a analizar:
</p>

</p><textarea rows="17" cols="60" wrap="off" style="overflow:auto" id="code3">943 static void extractAlbumArt(
944        const sp&lt;MetaData&gt; &amp;fileMeta, const void *data, size_t size) {
945    ALOGV("extractAlbumArt from '%s'", (const char *)data);
946
947    size_t flacSize;
948    uint8_t *flac = DecodeBase64((const char *)data, size, &amp;flacSize);
949
950    if (flac == NULL) {
951        ALOGE("malformed base64 encoded data.");
952        return;
953    }
954
955    ALOGV("got flac of size %zu", flacSize);
956
957    uint32_t picType;

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code3');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>

<p>
Las variables locales son leídas directamente desde el buffer de entrada como enteros sin signo. Luego serán utilizados para realizar aritmética de punteros para indexar el buffer de entrada. 
</p>
<p>
La validación de estas variables dentro de extractAlbumArt no considera que los cálculos con los valores podrían a generar overlfows que no sean detectados por las condiciones de error. 
</p>

</p><textarea rows="5" cols="60" wrap="off" style="overflow:auto" id="code4">958    uint32_t typeLen;
959    uint32_t descLen;
960    uint32_t dataLen;

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code4');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>

<p>
Puede generarse un overflow en el buffer de tipo fijo en la llamada al memcpy en la linea 983.
</p>

</p><textarea rows="26" cols="60" wrap="off" style="overflow:auto" id="code5">961    char type[128];
962
963    if (flacSize &lt; 8) {
964        goto exit;
965    }
966
967    picType = U32_AT(flac);
968
969    if (picType != 3) {
970        // This is not a front cover.
971        goto exit;
972    }
973
974    typeLen = U32_AT(&amp;flac[4]);
975    if (typeLen + 1 &gt; sizeof(type)) {
976        goto exit;
977    }
978
979    if (flacSize &lt; 8 + typeLen) {
980        goto exit;
981    }
982
983    memcpy(type, &amp;flac[8], typeLen);
984    type[typeLen] = '\0';

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code5');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>

<p>
Pasando typeLen como 0xffffffff hará que se pasen las dos condiciones mencionadas en el código y llevar a una corrupción de memoria al llamarse al memcpy. El archivo POC_typeLen_overflow.ogg es una prueba de concepto de este bug. 
</p>
<p>
Afortunadamente, el overflow es detectado en las versiones de Android compiladas con -DFORTIFY_SOURCE (&gt;= 4.2_r1) pero versiones anteriores podrían ser explotables. 
</p>
<p>
Al menos otro bug existe en el restante código:
</p>

</p><textarea rows="28" cols="60" wrap="off" style="overflow:auto" id="code6">985
986    ALOGV("picType = %d, type = '%s'", picType, type);
987
988    if (!strcmp(type, "--&gt;")) {
989        // This is not inline cover art, but an external url instead.
990        goto exit;
991    }
992
993    descLen = U32_AT(&amp;flac[8 + typeLen]);
994
995    if (flacSize &lt; 32 + typeLen + descLen) {
996        goto exit;
997    }
998
999    dataLen = U32_AT(&amp;flac[8 + typeLen + 4 + descLen + 16]);
1000
1001    if (flacSize &lt; 32 + typeLen + descLen + dataLen) {
1002        goto exit;
1003    }
1004
1005    ALOGV("got image data, %zu trailing bytes",
1006         flacSize - 32 - typeLen - descLen - dataLen);
1007
1008    fileMeta-&gt;setData(
1009            kKeyAlbumArt, 0, &amp;flac[8 + typeLen + 4 + descLen + 20], dataLen);
1010
1011    fileMeta-&gt;setCString(kKeyAlbumArtMIME, type);
1012
1013 exit:
1014    free(flac);
1015    flac = NULL;
1016 }
1017

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code6');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>

<p>
Como en el caso de 'typeLen', se puede ver que 'descLen' y 'dataLen' son leídos directamente desde el buffer de entrada pero las verificaciones que intentan comprobar que no pasen el tamaño del input fallan contemplar que tamaños muy grandes sufran overflow cuando se sumen.
</p>

<p>
Un tamaño grande de dataLen podría desencadenar una corrupción de memoria en la llamada a setData en la linea 1008.
</p>
<p>
Para investigar más, se puede ver el método setData  <a target="_blank" href="http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/MetaData.cpp#269">metaData.cpp</a> 
</p>

</p><textarea rows="11" cols="60" wrap="off" style="overflow:auto" id="code7">269 void MetaData::typed_data::setData(
270        uint32_t type, const void *data, size_t size) {
271    clear();
272
273    mType = type;
274    allocateStorage(size);
275    memcpy(storage(), data, size);
276 }
277

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code7');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>
<p>
El método llama a allocateStorage() para reservar un buffer interno y luego copia el buffer de entrada en él.
Desafortunadamente no verifica que el resultado de la llamada a allocateStorage() falle lo que podría generar una corrupción de memoria en la linea 275. El archivo POC_dataLen_overflow.ogg muestra dicho bug.
</p>

  
  <h3>8.
					Cronología del reporte</h3>
    <p>
          
      <ul><li class="smbull3"><strong>2015-08-12: </strong>
        Se abrió un issue en el Android issue Tracker. Se enviaron detalles técnicos de las vulnerabilidades al fabricante.
        </li><li class="smbull3"><strong>2015-08-13: </strong>
        El fabricante marcó la vulnerabilidad como un duplicado del issue 182053 reportado en el 4 de Agosto de 2015 (AndroidID-23036083).
        </li><li class="smbull3"><strong>2015-08-13: </strong>
        Se mergea el issue 182921 a este issue (posiblemente un reporte de tercero independiente de la misma vulnerabilidad).
        </li><li class="smbull3"><strong>2015-08-17: </strong>
        Se le asigna CVE-2015-3869 a esta vulnerabilidad.
        </li><li class="smbull3"><strong>2015-08-17: </strong>
        Se mergea el issue 184064, otro repote independiente de la misma vulnerabilidad.
        </li><li class="smbull3"><strong>2015-10-05: </strong>
        Se publica el Nexus security bulletin en Octubre de 2015 .
        </li><li class="smbull3"><strong>2015-10-09: </strong>
        El fabricante publicó un parche en el repositorio Android Open Source Project (AOSP).
        </li><li class="smbull3"><strong>2015-12-1: </strong>
        El reporte fue publicado.
        </li></ul>
    </p>
  
  
  <h3>9.
					Referencias</h3>
    <p/>
  
  
  <h3>10.
					Acerca Fundación Dr. Manuel Sadosky</h3>
    <p>
      La Fundación Dr. Manuel Sadosky es una institución público privada cuyo objetivo es favorecer la articulación entre el sistema científico – tecnológico y la estructura productiva en todo lo referido a la temática de las Tecnologías de la Información y la Comunicación (TIC). Creada a través del Decreto Nro. 678/09 del Poder Ejecutivo Nacional, la Fundación es presidida por el ministro de Ciencia, Tecnología e Innovación Productiva. Sus vicepresidentes son los presidentes de las cámaras más importantes del sector TIC: CESSI (Cámara de Empresas de Software y Servicios Informáticos) y CICOMRA (Cámara de Informática y Comunicaciones de la República Argentina). Para más información visitar: <a href="#">http://www.fundacionsadosky.org.ar</a>
    </p>    
  
  
  <h3>11.
					Derechos de autor</h3>
    <p>
      El contenido de este reporte tiene copyright (c) 2014 Fundación Sadosky y se publica bajo la licencia Creative Commons Attribution Non-Commercial Share-Alike 4.0: 
      <a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">http://creativecommons.org/licenses/by-nc-sa/4.0/</a>
    </p>
  
  
  
  
 
</body></html>