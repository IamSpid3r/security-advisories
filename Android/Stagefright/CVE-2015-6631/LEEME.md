<?xml version="1.0" encoding="UTF-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:xdt="http://www.w3.org/2005/xpath-datatypes" xmlns:err="http://www.w3.org/2005/xqt-errors"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><title>Fundación Dr. Manuel Sadosky - Programa STIC Advisory</title><script language="javascript">
						function showFullCode(textareaId)
						{
								theTextArea = document.getElementById(textareaId);
								content = theTextArea.value.split(String.fromCharCode(10));
								height = (400 + content.length % 500) % 800;
								win = window.open("", "Window3", "width=800,height=" + height + ",scrollbars=yes");
								win.document.writeln("<pre>" + theTextArea.innerHTML + "</pre>");
								win.document.close();
								return false;
						 }
					</script></head><body><div id="content-title">Divulgación de información sensible en biblioteca de Android que procesa archivos de audio en formato MP3</div>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <h3>1.
					Información del reporte</h3>
    <p>
      <strong>Título: </strong>Divulgación de información sensible en biblioteca de Android que procesa archivos de audio en formato MP3<br/><strong>Reporte ID: </strong>CVE-2015-6631<br/><strong>Reporte URL: </strong><a target="_blank" href="http://www.fundacionsadosky.org.ar/publicaciones-2">http://www.fundacionsadosky.org.ar/publicaciones-2</a><br/><strong>Fecha de publicación: </strong>2015-12-01<br/><strong>Fecha de última actualización: </strong>2015-12-1<br/><strong>Fabricantes contactados: </strong>Google<br/><strong>Modo de publicación: </strong>Coordinado<br/>
    </p>        
  
  
  <h3>2.
					Información de vulnerabilidades</h3>
    <p>
      <strong>Clase: </strong>Integer Overflow [<a target="_blank" href="http://cwe.mitre.org/data/definitions/190.html">CWE-190</a>]<br/><strong>Impacto: </strong>Perdida de datos<br/><strong>Remotamente explotable: </strong>Yes<br/><strong>Localmente explotable: </strong>No<br/><strong>Identificador CVE: </strong><a target="_blank" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-6631">CVE-2015-6631</a><br/>
    </p>
  
  
<h3>3.
					Descripción de vulnerabilidad</h3>
<p>
Stagefright es una biblioteca que corre en dispositivos con sistema operativo Android utilizada para procesar contenido multimedia de archivos con formatos tales como MP3, MP4, MKV, etc. 
</p>
<p>
Existe una vulnerabilidad en la biblioteca que se manifiesta al procesar archivos de audio con formato MP3 que incluyan un encabezado de tipo ID3 malformado. El bug puede ser utilizado por un potencial atacante para obtener información del entorno de ejecución de dispositivos móviles vulnerables que facilite eludir mecanismos de protección de Android diseñados para impedir o dificultar ataques informáticos.
</p>
<p>
Para explotar el problema, un potencial atacante requeriría que la victima abra un archivo MP3 que incluya un encabezado tipo ID3 diseñado especialmente para el ataque. Esto podría lograrse ya sea enviado el archivo en un mensaje de texto, engañando al la víctima para que lo descarge de un sitio web controlado por el atacante o copiandolo desde alguna aplicación instalada en el dispositivo, por ejemplo alguna de mensajería instantánea.
</p>
<p>
 El problema fue catalogado como de alta severidad por el fabricante (Google) y afecta aproximadamente al 93% de los dispositivos móviles Android de todo el mundo.
</p>

<h3>4.
					Paquetes vulnerables</h3>
<p>
<ul>
  <li class="smbull3">Dispositivos corriendo Android Lollipop 5.1.1 o menor, sin las actualizaciones de seguridad de Octubre de 2015.</li>
</ul>
</p>


<h3>5.
					Información y soluciones del fabricante</h3>
<p>
El fabricante solucionó el problema en el repositorio Android Open Source Project (AOSP) en Diciembre del 2015 y notificó a sus asociados en Noviembre 2, 2015. 
</p>


<h3>6.
					Créditos</h3>
<p>
Las vulnerabilidades fueron descubiertas e investigadas por Joaquín Manuel Rinaudo. La publicación de este reporte fue coordinada por Programa Seguridad en TIC. 
</p>


<a id="td"></a><h3>7.
					Descripción técnica</h3>
<p>
La vulnerabilidad consiste en el desbordamiento de una variable de tipo entero utilizada para indicar el tamaño de la fuente de datos. EL valor de la variable se calcula utilizando datos leídos directamente del encabezado ID3 del archivo potencialmente malformado y no se controlan correctamente. Como resultado es posible especificar un tamaño de fuente de datos muy grande, que supere el tamaño de la memoria utilizada por la variable almacenamiento temporario de los datos, causando que al momento de realizarse una operación de copia, se revele información sobre las estructuras internas del proceso, por ejemplo punteros a memoria y la disposición del heap, que permiten evaidr mecanismos de seguridad, como ASLR, diseñados para impedir la explotación de vulnerabilidades.
</p>
<p>
El procesamiento de la metadata de ID3 en archivos MP3 se realiza por el método parseV2 que se encuentra en <a target="_blank" href="http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/id3/ID3.cpp#118">ID3.cpp</a> 
</p>

<p>
Cuando la variable "version_major" es igual a 3 y el flag de 0x40 está encendido, el siguiente código es alcanzado:
</p>

</p><textarea rows="28" cols="60" wrap="off" style="overflow:auto" id="code1">226    mFirstFrameOffset = 0;
227    if (header.version_major == 3 &amp;&amp; (header.flags &amp; 0x40)) {
228        // Version 2.3 has an optional extended header.
229
230        if (mSize &lt; 4) {
231            free(mData);
232            mData = NULL;
233
234            return false;
235        }
236
237        size_t extendedHeaderSize = U32_AT(&amp;mData[0]) + 4;
238
239        if (extendedHeaderSize &gt; mSize) {
240            free(mData);
241            mData = NULL;
242
243            return false;
244        }
245
246        mFirstFrameOffset = extendedHeaderSize;
247
248        uint16_t extendedFlags = 0;
249        if (extendedHeaderSize &gt;= 6) {
250            extendedFlags = U16_AT(&amp;mData[4]);
251
252            if (extendedHeaderSize &gt;= 10) {
253                size_t paddingSize = U32_AT(&amp;mData[6]);
254
255                if (mFirstFrameOffset + paddingSize &gt; mSize) {
256                    free(mData);
257                    mData = NULL;
258
259                    return false;
260                }
261
262                mSize -= paddingSize;
263            }
264
265            if (extendedFlags &amp; 0x8000) {
266                ALOGV("have crc");
267            }
268        }

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code1');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>

<p>
En la linea 237, se lee 'extendedHeaderSize' desde el buffer de entrada como un entero sin signo de 32 bits más 4. 

</p>

<p>
En la 246, el valor de 'extendedHeaderSize' es asignado a 'mFirstFrameOffset', también definido como entero sin signo.
</p>

<p>
Por último, en la 253 otro entero sin signo es leído desde el buffer de entrada y se le asigna a la variable 'paddingSize'. 
</p>

<p>
El condicional en la linea 255 intenta verificar que la suma del tamaño del encabezado extendido más el padding no exceda el tamaño total del buffer de entrada pero dado que ambos son enteros sin signo de 32 bits, varias combinaciones de valores grandes de ambos podrían llevar a un overflow en la suma que haga que la condición falle y se continue la ejecución.
</p>

<p>
Luego, en la linea 262, la variable 'paddingSize' es substraída de el miembro privado 'mSize', que contiene el tamaño total del buffer de entrada. Como resultado, un valor grande de 'paddingSize' podría terminar incrementando el tamaño declarado del buffer, llevando a la divulgación de información de las estructuras internal del heap más adelante.
</p>

<p> 
Por ejemplo, el siguiente encabezado de ID3 pasa la verificación en la linea 255 dado que extendedHeaderSize + 4 + padding Size == 0, luego mSize menos FF FF C0 80 aumenta el tamaño del buffer en lugar de disminuirlo.
</p>

</p><textarea rows="4" cols="60" wrap="off" style="overflow:auto" id="code2">"ID3"      |version | flags   |   mSize        | extendedHeaderSize | flags  | paddingSize
49 44 33   |   03   | 00 40   | 00 00 7F 7F    | 00 00 3F 7C        | 0000   | FF FF C0 80

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code2');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>

<p>
Notar que mSize se lee con ParseSyncsafeInteger en la linea <a target="_blank" href="http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/id3/ID3.cpp#170">170</a> y su valor se establece con 0x3FFF en la linea 185 (al utilizar la anterior estructura).
</p>

<p>
Luego cuando el album art es extraído con getAlbumArt(), las verificaciones que no se lea fuera del buffer de datos fallarán y datos por fuera del buffer de mData serán copiados.
</p>

</p><textarea rows="28" cols="60" wrap="off" style="overflow:auto" id="code3">779 ID3::getAlbumArt(size_t *length, String8 *mime) const {
780    *length = 0;
781    mime-&gt;setTo("");
782
783    Iterator it(
784            *this,
785            (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) ? "APIC" :
"PIC");
786
787    while (!it.done()) {
788        size_t size;
789        const uint8_t *data = it.getData(&amp;size);
790
791        if (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) {
792            uint8_t encoding = data[0];
793            mime-&gt;setTo((const char *)&amp;data[1]);
794            size_t mimeLen = strlen((const char *)&amp;data[1]) + 1;
795
796            uint8_t picType = data[1 + mimeLen];
797 #if 0
798            if (picType != 0x03) {
799                // Front Cover Art
800                it.next();
801                continue;
802            }
803 #endif
804
805            size_t descLen = StringSize(&amp;data[2 + mimeLen], encoding);
806
807            *length = size - 2 - mimeLen - descLen;
808
809            return &amp;data[2 + mimeLen + descLen];

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code3');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>

<p>
Cuando getAlbumArt es alcanzado, el findFrame de ID3::Iterator establece los datos del frame. 
</p>

</p><textarea rows="15" cols="60" wrap="off" style="overflow:auto" id="code4">394 ID3::Iterator::Iterator(const ID3 &amp;parent, const char *id)
395    : mParent(parent),
396      mID(NULL),
397      mOffset(mParent.mFirstFrameOffset),
398      mFrameData(NULL),
399      mFrameSize(0) {
400    if (id) {
401        mID = strdup(id);
402    }
403
404    findFrame();
405 }
406

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code4');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>
<p>
<a target="_blank" href="http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/id3/ID3.cpp#findFrame">findFrame</a> permite a un frame leer fuera del buffer real dado al incremento de mSize:
</p>

</p><textarea rows="28" cols="60" wrap="off" style="overflow:auto" id="code5">void ID3::Iterator::findFrame() {
615    for (;;) {
616        mFrameData = NULL;
617        mFrameSize = 0;
618
619        if (mParent.mVersion == ID3_V2_2) {
620            if (mOffset + 6 &gt; mParent.mSize) {
621                return;
622            }
623
624            if (!memcmp(&amp;mParent.mData[mOffset], "\0\0\0", 3)) {
625                return;
626            }
627
628            mFrameSize =
629                (mParent.mData[mOffset + 3] &lt;&lt; 16)
630                | (mParent.mData[mOffset + 4] &lt;&lt; 8)
631                | mParent.mData[mOffset + 5];
632
633            mFrameSize += 6;
634
635            if (mOffset + mFrameSize &gt; mParent.mSize) {
636                ALOGV("partial frame at offset %zu (size = %zu,
bytes-remaining = %zu)",
637                    mOffset, mFrameSize, mParent.mSize - mOffset -
(size_t)6);
638                return;
639            }
640
641            mFrameData = &amp;mParent.mData[mOffset + 6];

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code5');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>
<p>
El siguiente frame establece a un album art que permitiría leer por fuera del buffer de mData al extraer el album art desde una aplicación.
</p>
</p><textarea rows="4" cols="60" wrap="off" style="overflow:auto" id="code6"> APIC      |  baseSize  |flags|       mimetype 'image/jpeg'     |  description 'images.jpg'
41504943   | 00001327   |0000 | 03696D6167652F6A70656700        | 03696D616765732E6A706700

</textarea><a class="codeLink" href="#" onclick="return showFullCode('code6');" style="display: block;align:right;font-family:'arial',verdana,geneva,sans-serif;font-size:10px;color:#AF0000;" >[+ full code]</a><p>
<p>
El tamaño de la imagen sería baseSize y la mayoría de los bytes leidos serían de memoria contigua fuera del buffer real de mData. En la prueba de concepto, para verificar que información está siendo divulgada, luego de la estructura del album art, se realiza un padding de valores de 0xFF hasta completar el tamaño 0x3FFF. La estructura del album art comienza en 0x3f80+a, es decir extendedHeaderSize -4 + 0xa (tamaño del encabezado). La información divulgada comienza luego del padding de 0xFF en los bytes de la imagen.

</p>


  
  <h3>8.
					Cronología del reporte</h3>
    <p>
          
      <ul><li class="smbull3"><strong>2015-08-21: </strong>
Se enviaron detalles de las vulnerabilidades técnicas y prueba de concepto al fabricante.
</li><li class="smbull3"><strong>2015-08-25: </strong>
Google pide el código fuente del APK
</li><li class="smbull3"><strong>2015-08-26: </strong>
Código fuente provisto a Google
</li><li class="smbull3"><strong>2015-09-02: </strong>
Etiquetado para testing automático del Fuzzer de clusterfuzz de Google.
</li><li class="smbull3"><strong>2015-10-02: </strong>
Programa STIC requiere noticias del problema
</li><li class="smbull3"><strong>2015-10-03: </strong>
Se le asigna el bug al equipo de ingeniería de Google con el ID AndroidID-24623447
</li><li class="smbull3"><strong>2015-10-12: </strong>
Issue 188891 fue unido con el problema.
</li><li class="smbull3"><strong>2015-10-15: </strong>
Issue 189777 fue unido con el problema.
</li><li class="smbull3"><strong>2015-10-19: </strong>
Se declara que se arregló en el repositorio interno y que el arreglo estará disponible en el siguiente Nexus Security Bulletin.
</li><li class="smbull3"><strong>2015-11-27: </strong>
Programa STIC requiere el ID del CVE asignado al bug.
</li><li class="smbull3"><strong>2015-11-30: </strong>
Google response que la asignación del CVE se realizará al publicar el parche. 
</li><li class="smbull3"><strong>2015-12-07: </strong>
Se publica la solución al problema. Además del Nexus Security Bulletin de Diciembre 2015.
</li><li class="smbull3"><strong>2015-12-16: </strong>
Google notifica que al bug se asignó el ID CVE-2015-6631.
</li><li class="smbull3"><strong>2015-12-1: </strong>
El reporte fue publicado.
</li></ul>
    </p>
  
  
  <h3>9.
					Referencias</h3>
    <p/>
  
  
  <h3>10.
					Acerca Fundación Dr. Manuel Sadosky</h3>
    <p>
      La Fundación Dr. Manuel Sadosky es una institución público privada cuyo objetivo es favorecer la articulación entre el sistema científico – tecnológico y la estructura productiva en todo lo referido a la temática de las Tecnologías de la Información y la Comunicación (TIC). Creada a través del Decreto Nro. 678/09 del Poder Ejecutivo Nacional, la Fundación es presidida por el ministro de Ciencia, Tecnología e Innovación Productiva. Sus vicepresidentes son los presidentes de las cámaras más importantes del sector TIC: CESSI (Cámara de Empresas de Software y Servicios Informáticos) y CICOMRA (Cámara de Informática y Comunicaciones de la República Argentina). Para más información visitar: <a href="#">http://www.fundacionsadosky.org.ar</a>
    </p>    
  
  
  <h3>11.
					Derechos de autor</h3>
    <p>
      El contenido de este reporte tiene copyright (c) 2014 Fundación Sadosky y se publica bajo la licencia Creative Commons Attribution Non-Commercial Share-Alike 4.0: 
      <a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">http://creativecommons.org/licenses/by-nc-sa/4.0/</a>
    </p>
  
  
  
  
 
</body></html>