
# Info leak in android library while parsing a MP3 audio files


## 1. Advisory Information

**Title:** Info leak in android library while parsing a MP3 audio files

**Advisory ID:** CVE-2015-6631

**Advisory URL:** [http://www.fundacionsadosky.org.ar/publicaciones-2](http://www.fundacionsadosky.org.ar/publicaciones-2)

**Date published:** 2015-12-1

**Date of last update:** 2015-12-01

**Vendors contacted:** Google

**Release mode:** Coordinated release



## 2. Vulnerability Information

**Class:** Integer Overflow [[http://cwe.mitre.org/data/definitions/190.html](http://cwe.mitre.org/data/definitions/190.html)]

**Impact:** Data loss

**Remotely Exploitable:** Yes

**Locally Exploitable:** No

**CVE Identifier:** [http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-6631](http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-6631)



## 3. Vulnerability Description

Stagefright is a media library running in Android devices used as a backend engine for playing various multimedia formats such as MP3, MKV, MP4, etc.

A vulnerability exists in the library that is triggered when procesing a malformed ID3 header in an MP3 audio file. The bug can be used by a potential attacker to obtain information about the execution environment of vulnerable devices that would help bypass Android's protection mechanism to hinder attacks. 

In order to exploit the problem an attacker would need a victim to open an MP3 file that includes an specially crafted ID3 header for the attack. This could be done via sending an MMS message to the device, tricking the user into browsing a site controlled by the attacker or sending it via to app installed in the victim's device such as an instant messaging app.

The problem was assigned as high severity by the vendor (Google) and it affects around 93% of Android mobile devices around the world.


## 4. Vulnerable packages

* Android Lollipop 5.1.1 without December security updates.

## 5. Vendor Information, Solutions and Workarounds

Vendor fixed issue in the Android Open Source Project (AOSP) repository on December 2015 and notified it's partners on November 2, 2015. 


## 6. Credits

This vulnerability was discovered and researched by Joaqu√≠n Manuel Rinaudo. The publication of this advisory was coordinated by Programa Seguridad en TIC. 

## 7. Technical Description

Parsing of ID3 metadata in MP3 audio file is done by the parseV2 method found in [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/id3/ID3.cpp#118](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/id3/ID3.cpp#118)
When header version major is 3 and flags is set to 4 the following code is used:

```
226    mFirstFrameOffset = 0;
227    if (header.version_major == 3 && (header.flags & 0x40)) {
228        // Version 2.3 has an optional extended header.
229
230        if (mSize < 4) {
231            free(mData);
232            mData = NULL;
233
234            return false;
235        }
236
237        size_t extendedHeaderSize = U32_AT(&mData[0]) + 4;
238
239        if (extendedHeaderSize > mSize) {
240            free(mData);
241            mData = NULL;
242
243            return false;
244        }
245
246        mFirstFrameOffset = extendedHeaderSize;
247
248        uint16_t extendedFlags = 0;
249        if (extendedHeaderSize >= 6) {
250            extendedFlags = U16_AT(&mData[4]);
251
252            if (extendedHeaderSize >= 10) {
253                size_t paddingSize = U32_AT(&mData[6]);
254
255                if (mFirstFrameOffset + paddingSize > mSize) {
256                    free(mData);
257                    mData = NULL;
258
259                    return false;
260                }
261
262                mSize -= paddingSize;
263            }
264
265            if (extendedFlags & 0x8000) {
266                ALOGV("have crc");
267            }
268        }


```

At line 237 'extendedHeaderSize' is read from the input buffer as an unsigned 32-bit integer plus 4.

At line 246 the value of 'extendedHeaderSize' is assigned to 'mFirstFrameOffset', also defined as an unsigned 32-bit integer.

At line 253 another unsigned 32-bit integer is read from the input buffer and assigned to the 'paddingSize' variable.

The conditional at line 255 attempts to verify that the sum of the size of the extended header plus the padding does not exceed the total length of the input buffer but since both are unsigned 32-bit integers several combinations of large values for them would make the sum overflow and wrap around to a small value that evaluates as false and allows execution to continue.

Then, at line 262 the declared 'paddingSize' is subtracted from the 'mSize' member, which holds the total length of the input buffer. As a result, a large 'paddingSize' could end up increasing the declared length of the input buffer, leading to  disclosure of internal heap structure information later on.

For example, the following ID3 header will pass the check at line 255 since extendedHeaderSize + 4 + padding Size == 0, then mSize minus FF FF C0 80 actually increases the buffer.

```
"ID3"      |version | flags   |   mSize        | extendedHeaderSize | flags  | paddingSize
49 44 33   |   03   | 00 40   | 00 00 7F 7F    | 00 00 3F 7C        | 0000   | FF FF C0 80


```

Note that using the previous structure, mSize is read with ParseSyncsafeInteger at line [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/id3/ID3.cpp#170](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/id3/ID3.cpp#170) and set as 0x3FFF at line 185.

Then when the album art is extracted in getAlbumArt() checks for buffer size will pass and data from outside de mData buffer will be copied.

```
779 ID3::getAlbumArt(size_t *length, String8 *mime) const {
780    *length = 0;
781    mime->setTo("");
782
783    Iterator it(
784            *this,
785            (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) ? "APIC" :
"PIC");
786
787    while (!it.done()) {
788        size_t size;
789        const uint8_t *data = it.getData(&size);
790
791        if (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) {
792            uint8_t encoding = data[0];
793            mime->setTo((const char *)&data[1]);
794            size_t mimeLen = strlen((const char *)&data[1]) + 1;
795
796            uint8_t picType = data[1 + mimeLen];
797 #if 0
798            if (picType != 0x03) {
799                // Front Cover Art
800                it.next();
801                continue;
802            }
803 #endif
804
805            size_t descLen = StringSize(&data[2 + mimeLen], encoding);
806
807            *length = size - 2 - mimeLen - descLen;
808
809            return &data[2 + mimeLen + descLen];


```

When getAlbumArt is reached, the findFrame of ID3::Iterator sets the frame data.

```
394 ID3::Iterator::Iterator(const ID3 &parent, const char *id)
395    : mParent(parent),
396      mID(NULL),
397      mOffset(mParent.mFirstFrameOffset),
398      mFrameData(NULL),
399      mFrameSize(0) {
400    if (id) {
401        mID = strdup(id);
402    }
403
404    findFrame();
405 }
406


```
[http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/id3/ID3.cpp#findFrame](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/id3/ID3.cpp#findFrame) allows frame to be read past the real buffer size due to the arbitrarily increased mSize:

```
void ID3::Iterator::findFrame() {
615    for (;;) {
616        mFrameData = NULL;
617        mFrameSize = 0;
618
619        if (mParent.mVersion == ID3_V2_2) {
620            if (mOffset + 6 > mParent.mSize) {
621                return;
622            }
623
624            if (!memcmp(&mParent.mData[mOffset], "\0\0\0", 3)) {
625                return;
626            }
627
628            mFrameSize =
629                (mParent.mData[mOffset + 3] << 16)
630                | (mParent.mData[mOffset + 4] << 8)
631                | mParent.mData[mOffset + 5];
632
633            mFrameSize += 6;
634
635            if (mOffset + mFrameSize > mParent.mSize) {
636                ALOGV("partial frame at offset %zu (size = %zu,
bytes-remaining = %zu)",
637                    mOffset, mFrameSize, mParent.mSize - mOffset -
(size_t)6);
638                return;
639            }
640
641            mFrameData = &mParent.mData[mOffset + 6];


```

The following data frame sets an album art that would allow reading past the mData buffer when extracting the album art from an application.

```
 APIC      |  baseSize  |flags|       mimetype 'image/jpeg'     |  description 'images.jpg'
41504943   | 00001327   |0000 | 03696D6167652F6A70656700        | 03696D616765732E6A706700


```


The image size will be baseSize and most of those bytes will be read from contiguous memory outside of mData real buffer. In the POC, to check that information is leaked, after the album structure, a padding of 0xFF values is done to complete to 0x3FFF size. The album art structure starts at 0x3f80+a, i.e extendedHeaderSize -4 + 0xa (size of header). The leaked information starts after the padding of 0xFF in the album art bytes read by the app.


## 8. Report Timeline

* **2015-08-21:** 
Reported to Google with technical description and a proof of
concept application.

* **2015-08-25:** 
Google asks for source code of the APK

* **2015-08-26:** 
Source code provided to Google

* **2015-09-02:** 
Tagged for automatic testing by Google's clusterfuzz

* **2015-10-02:** 
Programa STIC requests an status update

* **2015-10-03:** 
bug assigned to Google engineering team, AndroidID-24623447

* **2015-10-12:** 
Issue 188891 merged into this issue.

* **2015-10-15:** 
Issue 189777 merged into this issue.

* **2015-10-19:** 
Google fixed the problem in its internal repository and assures the fix be available in a
future Nexus Security Bulletin.

* **2015-11-27:** 
Programa STIC requests CVE ID assigned to the bug

* **2015-11-30:** 
Google replies that assigning a CVE is later done when releasing the
patch

* **2015-12-07:** 
Fix released. Nexus Security Bulletin - December 2015 published

* **2015-12-16:** 
Google notifies that CVE-2015-6631 was assigned to the bug

* **2015-12-1:** 
The advisory was published.


## 9. References



## 10. About Fundaci√≥n Dr. Manuel Sadosky

The Dr. Manuel Sadosky Foundation is a mixed (public / private) institution whose goal is to promote stronger and closer interaction between industry and the scientific-technological system in all aspects related to Information and Communications Technology (ICT). The Foundation was formally created by a Presidential Decree in 2009. Its Chairman is the Minister of Science, Technology, and Productive Innovation of Argentina; and the Vice-chairmen are the chairmen of the country‚Äôs most important ICT chambers: The Software and Computer Services Chamber (CESSI) and the Argentine Computing and Telecommunications Chamber (CICOMRA). For more information visit: [http://www.fundacionsadosky.org.ar](http://www.fundacionsadosky.org.ar)

## 11. Copyright Notice

The contents of this advisory are copyright (c) 2014 Fundaci√≥n Sadosky and are licensed under a Creative Commons Attribution Non-Commercial Share-Alike 4.0 License: [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/)