
# Vulnerabilidad en biblioteca de Android que procesa contenido multimedia con mecanismos de protección de derechos digitales


## 1. Información del reporte

**Título:** Vulnerabilidad en biblioteca de Android que procesa contenido multimedia con mecanismos de protección de derechos digitales

**Reporte ID:** CVE-2015-3873

**Reporte URL:** [http://www.fundacionsadosky.org.ar/publicaciones-2](http://www.fundacionsadosky.org.ar/publicaciones-2)

**Fecha de publicación:** 2015-12-01

**Fecha de última actualización:** 2016-1-22

**Fabricantes contactados:** Google

**Modo de publicación:** Coordinado



## 2. Información de vulnerabilidades

**Clase:** Integer Overflow to Buffer Overflow [[http://cwe.mitre.org/data/definitions/680.html](http://cwe.mitre.org/data/definitions/680.html)]

**Impacto:** Ejecución de código

**Remotamente explotable:** Yes

**Localmente explotable:** No

**Identificador CVE:** [http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-3873](http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-3873)



## 3. Descripción de vulnerabilidad

Stagefright es una biblioteca que corre en dispositivos Android que es utilizada como motor multimedia al procesar formatos como MP3, MP4, MKV, etc. La biblioteca permite que proveedores de contenidos gestionen sus derechos de propiedad intelectual e impongan restricciones de licenciamiento y de uso a los usuarios, a través de una interfaz de programación que permite interactuar con servicios de DRM (Digital Rights Management) de Android que corren en los dispositivos móviles.

Existe una vulnerabilidad en la biblioteca que se manifiesta al procesar archivos de video que utilicen los mecanismos de protección de derechos de propiedad intelectual para contenidos digitales (DRM) de Android. Para explotar el problema, un potencial atacante requeriría que la victima reproduzca un video con contenido protegido. Esto podría lograrse ya sea enviando el video en un mensaje de texto, engañando a la víctima para que navegue a una página web con dicho video embebido o copiándolo desde alguna aplicación instalada en el dispositivo, por ejemplo alguna de mensajería instantánea.

 El problema fue catalogado como de severidad crítica por el fabricante (Google) y afecta aproximadamente al 93% de los dispositivos móviles Android de todo el mundo.


## 4. Paquetes vulnerables

* Dispositivos corriendo Android Lollipop 5.1.1 o menor, sin las actualizaciones de seguridad de Octubre de 2015.

## 5. Información y soluciones del fabricante

El fabricante solucionó el problema en el repositorio Android Open Source Project (AOSP) en Octubre del 2015 y notificó a sus asociados en Septiembre 10, 2015. 


## 6. Créditos

Las vulnerabilidades fueron descubiertas e investigadas por Joaquín Manuel Rinaudo. La publicación de este reporte fue coordinada por Programa Seguridad en TIC. 

## 7. Descripción técnica

En libstagefright, la clase [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/MediaExtractor.cpp](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/MediaExtractor.cpp) procesa contenido media basado en DRM (con tipo MIME "drm+es_based+").

Primero MediaExtractor abrirá la fuente de datos (archivo DRM) e intentará detectar su tipo iterando sobre los métodos registrados en DataSource:

```
53 sp<MediaExtractor> MediaExtractor::Create(
54        const sp<DataSource> &source, const char *mime) {
55    sp<AMessage> meta;
56
57    String8 tmp;
58    if (mime == NULL) {
59        float confidence;
60        if (!source->sniff(&tmp, &confidence, &meta)) {
61            ALOGV("FAILED to autodetect media content.");
62
63            return NULL;
64        }
65
66        mime = tmp.string();
67        ALOGV("Autodetected media content as '%s' with confidence %.2f",
68             mime, confidence);
69    }
70


```

Para contenido DRM, esto terminará llamando a SniffDRM() que inicializará el un DRMClient para comunicarse con el DRMManagerService y crear un DRMExtractor para procesar el contenido. 

```
75   if (!strncmp(mime, "drm+", 4)) {
76        const char *originalMime = strchr(mime+4, '+');
77        if (originalMime == NULL) {
78            // second + not found
79            return NULL;
80        }
81        ++originalMime;
82        if (!strncmp(mime, "drm+es_based+", 13)) {
83            // DRMExtractor sets container metadata kKeyIsDRM to 1
84            return new DRMExtractor(source, originalMime);


```

En caso de contenido de video (AVC) con DRM basado en stream, durante el playback el método read de DRMExtractor llamará al método de desencripción correspondiente al servicio DRM y procesará su output de la siguiente forma:

```
126 status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {
127    Mutex::Autolock autoLock(mDRMLock);
128    status_t err;
129    if ((err = mOriginalMediaSource->read(buffer, options)) != OK) {
130        return err;
131    }
132
133    size_t len = (*buffer)->range_length();
134
135    char *src = (char *)(*buffer)->data() + (*buffer)->range_offset();
136
137    DrmBuffer encryptedDrmBuffer(src, len);
138    DrmBuffer decryptedDrmBuffer;
139    decryptedDrmBuffer.length = len;
140    decryptedDrmBuffer.data = new char[len];
141    DrmBuffer *pDecryptedDrmBuffer = &decryptedDrmBuffer;
142
143    if ((err = mDrmManagerClient->decrypt(mDecryptHandle, mTrackId,
144            &encryptedDrmBuffer, &pDecryptedDrmBuffer)) != NO_ERROR) {
145
146        if (decryptedDrmBuffer.data) {
147            delete [] decryptedDrmBuffer.data;
148            decryptedDrmBuffer.data = NULL;
149        }
150
151        return err;
152    }
153    CHECK(pDecryptedDrmBuffer == &decryptedDrmBuffer);
154
155    const char *mime;
156    CHECK(getFormat()->findCString(kKeyMIMEType, &mime));
157
158    if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) && !mWantsNALFragments) {
159        uint8_t *dstData = (uint8_t*)src;
160        size_t srcOffset = 0;
161        size_t dstOffset = 0;
162
163        len = decryptedDrmBuffer.length;
164        while (srcOffset < len) {
165            CHECK(srcOffset + mNALLengthSize <= len);
166            size_t nalLength = 0;
167            const uint8_t* data = (const uint8_t*)(&decryptedDrmBuffer.data[srcOffset]);
168
169            switch (mNALLengthSize) {
170                case 1:
171                    nalLength = *data;
172                    break;
173                case 2:
174                    nalLength = U16_AT(data);
175                    break;
176                case 3:
177                    nalLength = ((size_t)data[0] << 16) | U16_AT(&data[1]);
178                    break;
179                case 4:
180                    nalLength = U32_AT(data);
181                    break;
182                default:
183                    CHECK(!"Should not be here.");
184                    break;
185            }
186
187            srcOffset += mNALLengthSize;
188
189            if (srcOffset + nalLength > len) {
190                if (decryptedDrmBuffer.data) {
191                    delete [] decryptedDrmBuffer.data;
192                    decryptedDrmBuffer.data = NULL;
193                }
194
195                return ERROR_MALFORMED;
196            }
197
198            if (nalLength == 0) {
199                continue;
200            }
201
202            CHECK(dstOffset + 4 <= (*buffer)->size());
203
204            dstData[dstOffset++] = 0;
205            dstData[dstOffset++] = 0;
206            dstData[dstOffset++] = 0;
207            dstData[dstOffset++] = 1;
208            memcpy(&dstData[dstOffset], &decryptedDrmBuffer.data[srcOffset], nalLength);
209            srcOffset += nalLength;
210            dstOffset += nalLength;
211        }
212
213        CHECK_EQ(srcOffset, len);
214        (*buffer)->set_range((*buffer)->range_offset(), dstOffset);
215
216    } else {
217        memcpy(src, decryptedDrmBuffer.data, decryptedDrmBuffer.length);
218        (*buffer)->set_range((*buffer)->range_offset(), decryptedDrmBuffer.length);
219    }
220
221    if (decryptedDrmBuffer.data) {
222        delete [] decryptedDrmBuffer.data;
223        decryptedDrmBuffer.data = NULL;
224    }
225
226    return OK;
227 } 


```

Los frames desencriptados del video que incluyen fragmentos NAL deberán ser preprocesados dentro del while loop en la linea 164. El loop concatena y copia en un único buffer todos los fragmentos, delimitándolos con la secuencia de bytes "\x00\x00\x00\x01". Esto ocurre de forma similar en el método read() del extractor de archivos MKV (MatroskaExtractor).

Las variables 'srcOffset', 'dstOffset' y 'nalLength', todas definidas como enteros de 32 bits sin signo (size_t) son utilizadas para indexar los buffers de entrada y salida para las operaciones de copia. 

En la linea 180 'nalLength' es cargada como un entero sin signo directamente desde el buffer de entrada (que fue previamente desencriptado por el servicio de DRM).

En la linea 189 el valor 'nalLength' provisto es utilizado para calculos de aritmética de punteros para asegurarse que el tamaño de 'len' bytes no sea excedido por los punteros que indexan a buffers de entrada y salida. Sin embargo, debido a que la corroboración se realiza sumando dos variables de tipo size_t, un tamaño suficientemente grande de 'nalLength' provocará un overflow y causará que la condición a evaluar sea falsa. Así se continuará procesando con un nalLength fuera de los limites de los buffer de entrada y salida. Luego en la linea 208, 'nalLength' se pasará como argumento a memcpy() lo que llevará a un heap overflow.

Pueder ser extremadamente difícil detectar o filtrar intentos de explotación de esta vulnerabilidad para lograr ejecución remota de código, incluso desde el mismo dispositivo Android, dado que el problema solo se manifiesta después de que el contenido malicioso, alojado en uno o varios cuadros de un video, sea descifrado exitosamente. Por otro lado, parecería ser una vulnerabilidad ideal para realizar ataques dirigidos con alta precisión y para evadir o dificultar tareas de análisis forense. Utilizando mecanismos de restricción para la reproducción de video que proveen los servicios DRM de Android, un atacante podría restrigir el blanco de los intentos de explotación a dispositivos móviles específicos o a un periodo de tiempo determinado.


## 8. Cronología del reporte

* **2015-08-18:** 
        Se enviaron detalles de las vulnerabilidades técnicas y prueba de concepto al fabricante.
        
* **2015-08-19:** 
        El fabricante marcó la vulnerabilidad como un duplicado de un issue previamente reportado (seguido como AndroidID-23016072) y aseguró que el problema ya había sido solucionado en un branch interno.
        
* **2015-08-19:** 
        Programa STIC consultó al fabricante acerca si se le había asignado un CVE.
        
* **2015-08-19:** 
        El fabricante informó que se le asignó el CVE-2015-3873.
        
* **2015-10-05:** 
        Se publica el boletín de seguridad Nexus de October de 2015.
        
* **2015-10-09:** 
        El fabricante publicó un parche en el repositorio Android Open Source Project (AOSP).
        
* **2016-1-22:** 
        El reporte fue publicado.
        

## 9. Referencias



## 10. Acerca Fundación Dr. Manuel Sadosky

La Fundación Dr. Manuel Sadosky es una institución público privada cuyo objetivo es favorecer la articulación entre el sistema científico – tecnológico y la estructura productiva en todo lo referido a la temática de las Tecnologías de la Información y la Comunicación (TIC). Creada a través del Decreto Nro. 678/09 del Poder Ejecutivo Nacional, la Fundación es presidida por el ministro de Ciencia, Tecnología e Innovación Productiva. Sus vicepresidentes son los presidentes de las cámaras más importantes del sector TIC: CESSI (Cámara de Empresas de Software y Servicios Informáticos) y CICOMRA (Cámara de Informática y Comunicaciones de la República Argentina). Para más información visitar: [http://www.fundacionsadosky.org.ar](http://www.fundacionsadosky.org.ar)

## 11. Derechos de autor

El contenido de este reporte tiene copyright (c) 2014 Fundación Sadosky y se publica bajo la licencia Creative Commons Attribution Non-Commercial Share-Alike 4.0: [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/)