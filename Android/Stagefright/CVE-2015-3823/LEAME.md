
# Vulnerabilidad en biblioteca de Android que procesa archivos de video Matroska (MKV)


## 1. Información del reporte

**Título:** Vulnerabilidad en biblioteca de Android que procesa archivos de video Matroska (MKV)

**Reporte ID:** CVE-2015-3823

**Reporte URL:** [http://www.fundacionsadosky.org.ar/publicaciones-2](http://www.fundacionsadosky.org.ar/publicaciones-2)

**Fecha de publicación:** 2015-12-01

**Fecha de última actualización:** 2015-12-1

**Fabricantes contactados:** Google

**Modo de publicación:** Coordinado



## 2. Información de vulnerabilidades

**Clase:** Integer Overflow to Buffer Overflow [[http://cwe.mitre.org/data/definitions/680.html](http://cwe.mitre.org/data/definitions/680.html)]

**Impacto:** Perdida de datos

**Remotamente explotable:** Yes

**Localmente explotable:** No

**Identificador CVE:** [http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-3823](http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-3823)



## 3. Descripción de vulnerabilidad

Stagefright es una biblioteca que corre en dispositivos Android que es utilizada como motor multimedia al procesar formatos como MP3, MP4, MKV, etc. 

Existe una vulnerabilidad en la biblioteca que se manifiesta al procesar archivos de audio con formato MKV. El bug puede ser utilizado por un potencial atacante para ejecutar comandos de manera remota en un dispositivo vulnerable y obtener acceso a los datos alojados en él.

Para explotar el problema, un potencial atacante requeriría que la victima abra un archivo MKV diseñado especialmente para el ataque. Esto podría lograrse ya sea enviado el archivo en un mensaje de texto, engañando al la víctima para que lo descarge de un sitio web controlado por el atacante o copiandolo desde alguna aplicación instalada en el dispositivo, por ejemplo alguna de mensajería instantánea.
 
 El problema fue catalogado como de severidad crítica por el fabricante (Google) y afecta aproximadamente al 93% de los dispositivos móviles Android de todo el mundo.


## 4. Paquetes vulnerables

* Dispositivos corriendo Android Lollipop 5.1.1 sin las actualizaciones de seguridad de Octubre.

## 5. Información y soluciones del fabricante

El fabricante solucionó el problema en el repositorio Android Open Source Project (AOSP) en Octubre del 2015 y notificó a sus asociados en Septiembre 10, 2015. El problema fue encontrado independientemente por Wish Wu de Trend Micro Inc pero su severidad fue originalmente menospreciada.


## 6. Créditos

Las vulnerabilidades fueron descubiertas e investigadas por Joaquín Manuel Rinaudo. La publicación de este reporte fue coordinada por Programa Seguridad en TIC. 

## 7. Descripción técnica

En libstagefright, MatroskaExtractor.cpp es utilizado para procesar archivos .MKV. El extractor llama a [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/matroska/MatroskaExtractor.cpp#read](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/matroska/MatroskaExtractor.cpp#read) para iterar sobre cada frame y pasa dos veces sobre la secuencia de fragmentos de NAL para reunirlos en un buffer más largo.

Las porciones relevantes de cóðigo de  Matroska:read() se muestran abajo:

```
616    size_t dstSize = 0;
617    MediaBuffer *buffer = NULL;
618    uint8_t *dstPtr = NULL;
619
620    for (int32_t pass = 0; pass < 2; ++pass) {
621        size_t srcOffset = 0;
622        size_t dstOffset = 0;
623        while (srcOffset + mNALSizeLen <= srcSize) {
624            size_t NALsize;
625            switch (mNALSizeLen) {
626                case 1: NALsize = srcPtr[srcOffset]; break;
627                case 2: NALsize = U16_AT(srcPtr + srcOffset); break;
628                case 3: NALsize = U24_AT(srcPtr + srcOffset); break;
629                case 4: NALsize = U32_AT(srcPtr + srcOffset); break;
630                default:
631                    TRESPASS();
632            }
633
634            if (srcOffset + mNALSizeLen + NALsize > srcSize) {
635                break;
636            }
637
638            if (pass == 1) {
639                memcpy(&dstPtr[dstOffset], "\x00\x00\x00\x01", 4);
640
641                memcpy(&dstPtr[dstOffset + 4],
642                       &srcPtr[srcOffset + mNALSizeLen],
643                       NALsize);
644            }
645
646            dstOffset += 4;  // 0x00 00 00 01
647            dstOffset += NALsize;
648
649            srcOffset += mNALSizeLen + NALsize;
650        }
651
652        if (srcOffset < srcSize) {
653            // There were trailing bytes or not enough data to complete
654            // a fragment.
655
656            frame->release();
657            frame = NULL;
658
659            return ERROR_MALFORMED;
660        }
661
662        if (pass == 0) {
663            dstSize = dstOffset;
664
665            buffer = new MediaBuffer(dstSize);
666
667            int64_t timeUs;
668            CHECK(frame->meta_data()->findInt64(kKeyTime, &timeUs));
669            int32_t isSync;
670            CHECK(frame->meta_data()->findInt32(kKeyIsSyncFrame,
&isSync));
671
672            buffer->meta_data()->setInt64(kKeyTime, timeUs);
673            buffer->meta_data()->setInt32(kKeyIsSyncFrame, isSync);
674
675            dstPtr = (uint8_t *)buffer->data();
676        }
677    }
678
679    frame->release();   

```

En cada frame de tipo AVC, una secuencia de fragmentos NAL es reunida en un gran buffer en donde los fragmentos son delimitados por la secuencia de 4-bytes "\x00\x00\x00\x01". El loop for de la linea 620 pasa dos veces por el mismo frame, en cada pasada la secuencia entera de fragmentos NAL es procesada dentro del while en la linea 623.  

En la primera pasada el tamaño necesario del buffer es calculado sumando el tamaño de cada fragmento más 4 del delimitador y guardados en la variable 'dstOffset' (linea 647). Un buffer del tamaño calculado es reservado en la linea 665. En la segunda pasada, el contenido de cada fragmento NAL es copiado dentro del buffer en la linea 641.

Las variables 'dstSize', 'dstOffset', 'srcOffset' y 'NALsize' son definidas como enteros sin signo de 32 bits (size_T) y por lo tanto cálculos aritméticos que los combinen podrían causar un overflow. Por otro lado, el memcpy() que es llamado en la linea 643 utilizará el tamaño especificado en el fragmento ('NALsize') como tercer argumento.

Es posible construir la secuencia de fragmentos de NAL para forzar un número arbitrario de iteraciones en el while loop que hará que la variable 'dstOffset' se dé vuelta y reservar un buffer de menor tamaño que el necesitado en la primera pasada. Luego en la segunda pasada, los fragmentos NAL seguidos con un NALsize grande desencadenará una corrupción en la llamada memcpy(). Para realizar esto, una secuencia de tamaños de NAL en los fragmentos debe dar vuelta la variable y pasar los condicionales en la linea 623 y 652.

Por ejemplo, asumiendo mNALSizeLen == 4 y un buffer de entrada (srcSize) de tamaño SZ, la siguiente secuencia de fragmentos creará una sobreescritura cuando se llama a memcpy en la segunda pasada.

```
|(SZ-8)|(SZ-8)| SZ-12 bytes| 0xFFFFFFFF - SZ + 9 |
|      |      |            |                     |
   4       4     SZ-12                4


```


## 8. Cronología del reporte

* **2015-08-15:** 
        Se abrió un issue en el Android issue Tracker. Se enviaron detalles técnicos de las vulnerabilidades al fabricante.
        
* **2015-08-15:**  notó que el issue parecería haber sido reportado y publicado previamente por Trendmicro pero que el análisis hecho en su blogspot subestimaba la explotabilidad del bug.
        
* **2015-08-17:** 
        Fabricante confirmó que el bug era un duplicado de la vulnerabilidad reportada por Trendmicro, interamente seguida como AndroidID-21335999. 
        
* **2015-08-17:**  notó que Trendmicro estimaba el impacto como un simple "loop infinito" (DoS) cuando en realidad se trata de una vulnerabilidad que permite ejecución remota de código.
        
* **2015-08-17:** 
        Fabricante estuvo de acuerdo con la nueva evaluación de seguridad, cambia la prioridad del bug de Medio a Crítico.
        
* **2015-08-18:** 
        Fabricante proveyó proveyó un parche privado para una revisión.
        
* **2015-08-21:**  confirmó que el parche corregía el bug correctamente y proporcionó dos casos de test de CTS.
        
* **2015-08-28:**  preguntó por una fecha estimada de publicación para la solución y comentó que Trendmicro también había cambiado la evaluación del impacto.
        
* **2015-08-30:** 
        Fabricante notificó que en Octubre de 2015 lanzarían una actualización para los dispositivos Nexus, al mismo tiempo que llegaría a AOSP y que notificaría a sus asociados en Septiembre. Fabricante preguntó acerca como Trendmicro descubrió que el impacto de la vulnerabilidad había sido cambiado. 
        
* **2015-08-30:**  notificó que había comentado en Twitter que la evaluación hecha por Trendmicro era erronea. Se le consultó al fabricante si los que reportaron el issue de Trendmicro no tenían acceso al issue reportado por  de todos modos dado que se había asignado como duplicado al bug de ellos. Se notó que esperar un mes adicional para que se publique la solución parecía demasiado y se preguntó si no iba a haber actualizaciones de seguridad en Septiembre 2015 o si sólo la vulnerabilidad no iba a ser incluida en dichas actualizaciones. 
       
* **2015-08-30:** 
        Fabricante fusiona el issue  183986 a este issue. Posiblemente un tercer reporte independientde la misma vulnerabilidad.
       
* **2015-09-03:** 
        Se le asigna al issue el CVE-2015-3823. 
        
* **2015-09-17:** 
        Fabricante informa que el arreglo estaba disponible para sus asociados y que se incluiría en el reporte de seguridad de Nexus de Octubre 2015.
        
* **2015-10-05:** 
          Se publicó el problema en Nexus Security Bulletin de octubre 2015.
        
* **2015-10-07:** 
        El fabricante publicó un parche en el repositorio Android Open Source Project (AOSP).
        
* **2015-12-1:** 
        El reporte fue publicado.
        

## 9. Referencias



## 10. Acerca Fundación Dr. Manuel Sadosky

La Fundación Dr. Manuel Sadosky es una institución público privada cuyo objetivo es favorecer la articulación entre el sistema científico – tecnológico y la estructura productiva en todo lo referido a la temática de las Tecnologías de la Información y la Comunicación (TIC). Creada a través del Decreto Nro. 678/09 del Poder Ejecutivo Nacional, la Fundación es presidida por el ministro de Ciencia, Tecnología e Innovación Productiva. Sus vicepresidentes son los presidentes de las cámaras más importantes del sector TIC: CESSI (Cámara de Empresas de Software y Servicios Informáticos) y CICOMRA (Cámara de Informática y Comunicaciones de la República Argentina). Para más información visitar: [http://www.fundacionsadosky.org.ar](http://www.fundacionsadosky.org.ar)

## 11. Derechos de autor

El contenido de este reporte tiene copyright (c) 2014 Fundación Sadosky y se publica bajo la licencia Creative Commons Attribution Non-Commercial Share-Alike 4.0: [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/)