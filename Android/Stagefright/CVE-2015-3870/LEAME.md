
# Vulnerabilidad en biblioteca de Android que procesa archivos de video MP4


## 1. Información del reporte

**Título:** Vulnerabilidad en biblioteca de Android que procesa archivos de video MP4

**Reporte ID:** CVE-2015-3870

**Reporte URL:** [http://www.fundacionsadosky.org.ar/publicaciones-2](http://www.fundacionsadosky.org.ar/publicaciones-2)

**Fecha de publicación:** 2015-12-01

**Fecha de última actualización:** 2016-1-22

**Fabricantes contactados:** Google

**Modo de publicación:** Coordinado



## 2. Información de vulnerabilidades

**Clase:** Heap-based Buffer Overflow [[http://cwe.mitre.org/data/definitions/122.html](http://cwe.mitre.org/data/definitions/122.html)]

**Impacto:** Ejecución de código

**Remotamente explotable:** Yes

**Localmente explotable:** No

**Identificador CVE:** [http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-3870](http://cve.mitre.org/cgi-bin/cvename.cgi?name=2015-3870)



## 3. Descripción de vulnerabilidad

Stagefright es una biblioteca que corre en dispositivos Android y es utilizada como motor multimedia al procesar formatos como MP3, MP4, MKV, etc. 

Existe una vulnerabilidad en la biblioteca que se manifiesta al procesar archivos de audio con formato MP4 malformado. El bug puede ser utilizado por un potencial atacante para ejecutar comandos de manera remota en un dispositivo vulnerable y obtener acceso a los datos alojados en él.

Para explotar el problema, un potencial atacante requeriría que la victima abra un archivo MP4 diseñado especialmente para el ataque. Esto podría lograrse ya sea enviando el archivo en un mensaje de texto, engañando a la víctima para que lo descargue de un sitio web controlado por el atacante o copiándolo desde alguna aplicación instalada en el dispositivo, por ejemplo alguna de mensajería instantánea.

 El problema fue catalogado como de severidad crítica por el fabricante (Google) y afecta aproximadamente al 93% de los dispositivos móviles Android de todo el mundo.


## 4. Paquetes vulnerables

* Dispositivos corriendo Android Lollipop 5.1.1 sin las actualizaciones de seguridad de Octubre.

## 5. Información y soluciones del fabricante

El fabricante solucionó el problema en el repositorio Android Open Source Project (AOSP) en Octubre del 2015 y notificó a sus asociados en Septiembre 10, 2015.


## 6. Créditos

Las vulnerabilidades fueron descubiertas e investigadas por Joaquín Manuel Rinaudo and Iván Arce. La publicación de este reporte fue coordinada por Programa Seguridad en TIC. 

## 7. Descripción técnica

Al procesar archivos multimedia mp4, libstagefright utiliza MPEG4Extrator para iterar los diferentes átomos llamando a [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#parseFileMetaData](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/OggExtractor.cpp#parseFileMetaData) para procesar elementos basados en 4 caracteres (fourCC) de cada átomo.

Al encontrar elementos con el código FourCC de "avcC" o "hvcC", el extractor reservará un buffer, almacenará el chunk en un array, lo marcará con una clave correspondiente al código fourCC y continuará con el procesamiento. 

El procesamiento de estos elementos se continua en convertMetaDataToMessage [http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/Utils.cpp](http://androidxref.com/5.1.1_r6/xref/frameworks/av/media/libstagefright/Utils.cpp)
Al comenzar la linea 177, se procesa el registro AVCDecoderConfiguration y se intenta aplanar una array de longitud variable en un buffer reservado con un tamaño fijo:

```
177    if (meta->findData(kKeyAVCC, &type, &data, &size)) {
178        // Parse the AVCDecoderConfigurationRecord
179
180        const uint8_t *ptr = (const uint8_t *)data;
181
182        CHECK(size >= 7);
183        CHECK_EQ((unsigned)ptr[0], 1u);  // configurationVersion == 1
184        uint8_t profile = ptr[1];
185        uint8_t level = ptr[3];
186
187        // There is decodable content out there that fails the following
188        // assertion, let's be lenient for now...
189        // CHECK((ptr[4] >> 2) == 0x3f);  // reserved
190
191        size_t lengthSize = 1 + (ptr[4] & 3);
192
193        // commented out check below as H264_QVGA_500_NO_AUDIO.3gp
194        // violates it...
195        // CHECK((ptr[5] >> 5) == 7);  // reserved
196
197        size_t numSeqParameterSets = ptr[5] & 31;
198
199        ptr += 6;
200        size -= 6;
201
202        sp<ABuffer> buffer = new ABuffer(1024);
203        buffer->setRange(0, 0);
204
205        for (size_t i = 0; i < numSeqParameterSets; ++i) {
206            CHECK(size >= 2);
207            size_t length = U16_AT(ptr);
208
209            ptr += 2;
210            size -= 2;
211
212            CHECK(size >= length);
213
214            memcpy(buffer->data() + buffer->size(), "\x00\x00\x00\x01", 4);
215            memcpy(buffer->data() + buffer->size() + 4, ptr, length);
216            buffer->setRange(0, buffer->size() + 4 + length);
217
218            ptr += length;
219            size -= length;
220        }


```

En la linea 202, un buffer de tamaño fijo es reservado, el loop en la linea 205 itera sobre un array de longitud variable de elementos. Para cada elemento, su tamaño es obtenido del archivo como un entero de 2 bytes y su correspondiente datos copiado dentro del buffer en la linea 215.

El CHECK() en la linea 212 asegura que la longitud no pase el buffer de entrada pero no previene que se sobrescriba la memoria del heap debido a que no corrobora que la longitud del tamaño proveído no exceda el tamaño del buffer reservado.

Un MP4 malformado con una registro AVCDecoderConfiguration que incluye registros SPS donde la suma de los datos de sus elementos excede el tamaño fijo del buffer corromperá el heap. Esto puede realizarse con un único elemento de 1020 bytes o con múltiples elementos de menor tamaño.

En cualquier caso, la llamada a setRange() en la linea 216 fallará al intentar fijar el rango del buffer pasando su tamaño reservado, terminando el proceso. En este punto el heap ya ha sido corrompido por el memcpy() en la linea 215. Es incierto si este issue puede ser explotado para algo diferente que la falla del proceso.
El mismo bug se encuentra dos veces más en Utils.cpp al procesar un registro  Picture Parameter Sets (PPS) en [https://android.googlesource.com/platform/frameworks/av/+/android-5.1.1_r13/media/libstagefright/Utils.cpp#235](https://android.googlesource.com/platform/frameworks/av/+/android-5.1.1_r13/media/libstagefright/Utils.cpp#235) y al procesar unidades NAL en registros HVCC en  [https://android.googlesource.com/platform/frameworks/av/+/android-5.1.1_r13/media/libstagefright/Utils.cpp#255](https://android.googlesource.com/platform/frameworks/av/+/android-5.1.1_r13/media/libstagefright/Utils.cpp#255)

## 8. Cronología del reporte

* **2015-08-05:** 
        Se abrió un issue en el Android issue Tracker. Se enviaron detalles técnicos de las vulnerabilidades al fabricante.
        
* **2015-08-06:** 
        Fabricante afirmó que no puede reproducir el problema dado que ya había un branch interno que lo solucionaba.
        
* **2015-08-06:** 
        Programa STIC pidió confirmación de si es considerado un problema de seguridad y se preguntó si se le asignaría un CVE o tres junto con una fecha estimada de publicación de la solución.
        
* **2015-08-17:** 
        Fabricante marca el problema como un issue de severidad Alta y le asigna el CVE-2015-3870. Dicho bug fue encontrado y arreglado internamente (como ANDROID-22771132) en Julio 2015.
        
* **2015-08-17:** 
        Programa STIC nota que el mismo patrón de la vulnerabilida se encuentra tres veces en Utils.cpp: Al procesar registros SPS y PPS en AVCC y al procesar HVCC en HEVC.
        
* **2015-08-25:** 
        Issue 183762 fue anexado a este issue. Se trata de un reporte duplicado de Wang Tao de Baidu X-Team.
        
* **2015-09-03:** 
        Se le asigna CVE-2015-3870 al issue.
        
* **2015-10-05:** 
        Se publica la solución en el Nexus security bulletin - Octubre 2015.
        
* **2015-10-09:** 
        El fabricante publicó un parche en el repositorio Android Open Source Project (AOSP).
        
* **2016-1-22:** 
        El reporte fue públicado.
        

## 9. Referencias



## 10. Acerca Fundación Dr. Manuel Sadosky

La Fundación Dr. Manuel Sadosky es una institución público privada cuyo objetivo es favorecer la articulación entre el sistema científico – tecnológico y la estructura productiva en todo lo referido a la temática de las Tecnologías de la Información y la Comunicación (TIC). Creada a través del Decreto Nro. 678/09 del Poder Ejecutivo Nacional, la Fundación es presidida por el ministro de Ciencia, Tecnología e Innovación Productiva. Sus vicepresidentes son los presidentes de las cámaras más importantes del sector TIC: CESSI (Cámara de Empresas de Software y Servicios Informáticos) y CICOMRA (Cámara de Informática y Comunicaciones de la República Argentina). Para más información visitar: [http://www.fundacionsadosky.org.ar](http://www.fundacionsadosky.org.ar)

## 11. Derechos de autor

El contenido de este reporte tiene copyright (c) 2014 Fundación Sadosky y se publica bajo la licencia Creative Commons Attribution Non-Commercial Share-Alike 4.0: [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/)